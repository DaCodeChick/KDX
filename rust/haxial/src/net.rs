use crate::tcp_packet_crypt;

use bytes::{Buf, BufMut};

pub const KDX: u32 = 0x254B4458;
pub const TXP: u32 = 0x25545850;

pub enum PacketError {
    Align(u8, u8), // expected, got
    DataSize(u8),  // should this really be a single byte?
    TXP(u32),
}

/// A packet of data sent via TCP (client<->server)
#[derive(Default)]
pub struct TCPPacket {
    key: u32, // The crypt key is not encrypted
    tag: u32, // '%KDX' from session
    drm_offset: u16,
    id: u64, // session ID
    data: Vec<u8>,
}

impl TCPPacket {
    pub fn from_bytes(buf: &[u8]) -> Result<Self, PacketError> {
        let mut key = &buf[0..4];
        let key = key.get_u32();
        let buf = tcp_packet_crypt(key, &buf[4..])
            .map_err(|_| PacketError::Align(4, (buf[4..].len() & 3) as u8))?;
        let mut buf = &buf[4..];

        let txp = buf.get_u32();
        if txp != TXP {
            return Err(PacketError::TXP(txp));
        }

        let tag = buf.get_u32();
        let _ = buf.get_u8(); // observed to have a value of 1
        let _ = buf.get_u8(); // assigned an unknown value from session (field29_0x99 in original Win32 decompilation)
        let _ = buf.get_u8(); // observed to have a value of 0

        let data_size = buf.get_u8();
        if (data_size as usize) < buf.remaining() {
            return Err(PacketError::DataSize(data_size));
        }

        let _ = buf.get_u32(); // observed to have a value of 0
        let _ = buf.get_u16(); // observed to have a value of 0
        let drm_offset = buf.get_u16();
        let id = buf.get_u64();
        let _ = buf.get_u16(); // assigned an unknown RNG value from session (field18_0x70 in original Win32 decompilation)

        Ok(Self {
            key: key,
            tag: tag,
            drm_offset: drm_offset,
            id: id,
            data: buf.take(data_size as usize).into_inner().to_vec(),
        })
    }

    /// Converts the packet to a byte slice. This does not include
    /// the encryption key.
    pub fn to_bytes(&self) -> Vec<u8> {
        let mut buf = vec![];

        buf.put_u32(self.key); // again, exclude from encryption
        buf.put_u32(TXP);
        buf.put_u32(self.tag);
        buf.put_u8(1);
        buf.put_u8(0);
        buf.put_u8(0);
        buf.put_u8(self.data.len() as u8);
        buf.put_u32(0);
        buf.put_u16(0);
        buf.put_u16(self.drm_offset);
        buf.put_u64(self.id);
        buf.put_u16(0);
        buf.put(&self.data[..]);

        if buf.len() & 3 != 0 {
            buf.put_bytes(0, buf.len() & 3); // pad to align for encryption
        }

        buf = tcp_packet_crypt(self.key, &buf[4..]).unwrap().to_vec(); // padding should ensure alignment

        buf
    }
}

/// A packet of data sent via UDP (client/server<->tracker)
pub struct UDPPacket {
    ver: u16, // currently 0x1000
    crc: u32,
    hashes: [u32; 3], // generated by server on startup
    user_port: u16,
    serv_token: u16,
    serv_kind: u8,
}
