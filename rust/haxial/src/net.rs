use crate::tcp_packet_crypt;

use bytes::{Buf, BufMut};

const TXP: u32 = 0x25545850;

pub enum PacketError {
    Align(u8, usize), // expected, got
    DataSize(u8),     // should this really be a single byte?
    TXP(u32),
}

/// A packet of data sent via TCP (client<->server)
/// The first 4 bytes are the encryption key, which is not encrypted.
#[derive(Default)]
pub struct TCPPacket {
    key: u32, // The crypt key is not encrypted
    tag: u32, // '%KDX' from session
    drm_offset: u16,
    user_arrival: u64,
    data: Vec<u8>,
}

impl TCPPacket {
	/// Creates a new TCP packet with the given data.
    pub fn from_bytes(buf: &[u8]) -> Result<Self, PacketError> {
        let mut key = &buf[0..4];
        let key = key.get_u32();
        let buf = tcp_packet_crypt(key, &buf[4..])
            .map_err(|_| PacketError::Align(4, buf[4..].len() & 3))?;
        let mut buf = &buf[4..];

        let txp = buf.get_u32();
        if txp != TXP {
            return Err(PacketError::TXP(txp));
        }

        let tag = buf.get_u32();
        let _ = buf.get_u8(); // observed to have a value of 1
        let _ = buf.get_u8(); // assigned an unknown value from session (field29_0x99 in original Win32 decompilation)
        let _ = buf.get_u8(); // observed to have a value of 0

        let data_size = buf.get_u8() as usize;
        if data_size < buf.remaining() {
            return Err(PacketError::DataSize(data_size));
        }

        let _ = buf.get_u32(); // observed to have a value of 0
        let _ = buf.get_u16(); // observed to have a value of 0
        let drm_offset = buf.get_u16();
        let user_arrival = buf.get_u64();
        let _ = buf.get_u16(); // assigned an unknown RNG value from session (field18_0x70 in original Win32 decompilation)

        Ok(Self {
            key: key,
            tag: tag,
            drm_offset: drm_offset,
            user_arrival: user_arrival,
            data: buf.take(data_size).into_inner().to_vec(),
        })
    }

    /// Creates a new TCP packet with the given data.
	/// The key is not encrypted, but the rest of the packet is.
    pub fn to_bytes(&self) -> Vec<u8> {
        let mut buf = vec![];

        buf.put_u32(self.key); // again, exclude from encryption
        buf.put_u32(TXP);
        buf.put_u32(self.tag);
        buf.put_u8(1);
        buf.put_u8(0);
        buf.put_u8(0);
        buf.put_u8(self.data.len() as u8);
        buf.put_u32(0);
        buf.put_u16(0);
        buf.put_u16(self.drm_offset);
        buf.put_u64(self.user_arrival);
        buf.put_u16(0);
        buf.put(&self.data[..]);

        let pad = buf.len() & 3;
        if pad != 0 {
            buf.put_bytes(0, pad); // pad to align for encryption
        }

        buf = tcp_packet_crypt(self.key, &buf[4..]).unwrap().to_vec(); // padding should ensure alignment

        buf
    }
}

//// A packet of data sent via UDP (client<->server)
pub struct UDPPacket {
    ver: u16, // currently 0x1000
    crc: u32,
    seeds: [u32; 3], // generated by server on startup
    user_port: u16,
    serv_token: u16,
    serv_kind: u8,
}
